<thinking>
1. Problem summary: Given a rooted weighted tree, select non-adjacent edges to maximize the total weight.
2. Problem type / algorithm category: Dynamic Programming on Trees.
3. Step-by-step approach: Build an adjacency list for the tree. Use a recursive DP function where dp(node, include_parent_edge) returns the maximum score for the subtree rooted at 'node', considering if the edge connecting to its parent was included or not. The state transition considers whether to include the edge to the current node or not, and recursively calls for children.
4. Edge cases: An empty tree or a tree with only one node (root) will have a max score of 0. Negative edge weights need to be handled by the max function.
5. Time and space complexity: O(N) time complexity due to visiting each node and edge once. O(N) space complexity for the recursion stack and the adjacency list/memoization.
</thinking>