<thinking>
1. Problem summary: Maximize taxi earnings by selecting optimal rides, given start, end points, and tips, without changing direction.
2. Problem type / algorithm category: Dynamic Programming with Memoization / Recursion.
3. Step-by-step approach: Sort rides by start time. Define a recursive function that, for each ride, either skips it or takes it. If taken, find the next non-overlapping ride and add its earnings. Memoize results to avoid redundant calculations.
4. Edge cases: No rides available, single ride, all rides overlapping.
5. Time and space complexity: O(m log m + m^2) time due to sorting and recursion with bisect_left, O(m) space for memoization, where m is the number of rides.
</thinking>