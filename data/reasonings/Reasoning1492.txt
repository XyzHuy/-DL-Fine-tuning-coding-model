<thinking>
1. Problem summary: Find the k-th smallest factor of a given integer n, or return -1 if n has fewer than k factors.
2. Problem type / algorithm category: Number theory, Factorization, Sorting.
3. Step-by-step approach: Iterate from 1 up to the square root of n. If a number i divides n, add both i and n/i to a list of factors (handling the square root case to avoid duplicates). Sort the collected factors and return the k-th element if k is within the list bounds, otherwise return -1.
4. Edge cases: n having less than k factors, the case where n is a perfect square (to avoid adding the square root twice).
5. Time and space complexity: Time complexity is O(sqrt(n) log(sqrt(n))) due to iterating up to sqrt(n) and sorting factors (at most 2*sqrt(n) factors). Space complexity is O(sqrt(n)) to store the factors.
</thinking>