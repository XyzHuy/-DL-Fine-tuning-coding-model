<thinking>
1. Problem summary: Given a string `s`, find the number of unique non-empty substrings of `s` that are present in the infinite wraparound string "abcdefghijklmnopqrstuvwxyz...".
2. Problem type / algorithm category: String manipulation, dynamic programming (although not explicitly stated, the `max_len_ending_with` dictionary implicitly uses a DP approach).
3. Step-by-step approach: Iterate through the input string `s`. Keep track of the current consecutive substring length. If the current character is consecutive to the previous one in the wrap-around string, increment the length. Otherwise, reset the length to 1. Update a dictionary `max_len_ending_with` that stores the maximum length of a substring ending with each character. Finally, sum the values in `max_len_ending_with` to get the result.
4. Edge cases: Empty input string (although the problem states that the length is at least 1). Consecutive characters wrapping around from 'z' to 'a'.
5. Time and space complexity: Time complexity is O(n), where n is the length of the string `s`, because we iterate through the string once. Space complexity is O(1), as the dictionary `max_len_ending_with` has a fixed size of 26.
</thinking>