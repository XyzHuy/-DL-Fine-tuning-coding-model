<thinking>
1. Problem summary: Find the minimum sum of a triplet (i, j, k) such that i < j < k and nums[i] < nums[j] and nums[k] < nums[j], or return -1 if no such triplet exists.
2. Problem type / algorithm category: Array, Two Pointers, Dynamic Programming (prefix/suffix min).
3. Step-by-step approach: Precompute minimums to the left and right of each index. Iterate through each index `j` as a potential peak. If `nums[j]` is greater than the precomputed minimum to its left and the precomputed minimum to its right, calculate the sum and update the minimum sum found so far.
4. Edge cases: Array length less than 3, no mountain triplet found.
5. Time and space complexity: O(n) time complexity due to three passes over the array, and O(n) space complexity for storing prefix and suffix minimums.
</thinking>